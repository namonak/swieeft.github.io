---
layout: post
title: "열거형(Enum) 기본편"
subtitle: "[Swift]"
date: 2020-02-29 00:20
background: 
tag: [iOS, Swift]
---
열거형이란, 연관된 항목을 묶어서 표현할 때 사용 되는 타입을 말합니다. 이미 지정된  항목 값 외에는 추가/수정이 불가능하여 다음의 경우에 많이 사용됩니다.

- 제한된 선택지를 줄 때
- 정해진 값 외에는 입력을 받지 않기 위해
- 예상 된 입력 값이 정해져 있을 때

스위프트의 열거형은 다른 언어의 열거형과는 많은 차이점이 있습니다. C언어를 예를 들면 C언어에서 열거형은 단순히 정수형의 닉네임을 정해 주는 형태로 사용 되었습니다. 그렇기 때문에 모든 열거형의 타입은 정수형으로 취급 되었고, 그렇기 때문에 열거형 각각의 고유 값을 가질 수 없어 실수로 잘못 사용 되어 버그가 발생하는 경우가 많이 있었습니다.

하지만 스위프트 열거형이 고유의 타입으로 존재하기 때문에 위와 같은 상황이 발생할 가능성을 막을 수 있습니다. 그리고 고유의 타입 뿐만 아니라 원시 값(Raw Value)이라는 형태로 정수, 실수, 문자 등의 실제 값을 가질 수 있습니다. 

서론이 길어 졌는데요. 그럼 열거형에 대해 하나하나 상세히 알아보도록 하겠습니다.

> 이해를 빠르게 하기 위해 열거형을 한글로 작성하도록 하겠습니다.

### 기본 열거형

---

열거형은 enum이라는 키워드를 이용해 선언할 수 있습니다. 

- **기본 열거형 선언**

    {% gist swieeft/e5ae1c27e5c97a32eadd38c8cf604825 EnumBasic-1.swift %}

    우리는 이제 분식집을 차려보려고 합니다. 분식집의 대표적인 메뉴 네가지를 선언한 열거형입니다. C언어에서는 위와 같이 선언되면 라면 = 0, 김밥 = 1, 찌개 = 2, 떡볶이 = 3 처럼 정수 값이 설정되지만 스위프트에서는 각각의 case 자체가 하나의 값이 되게 됩니다.

- **열거형 한 줄 로 선언**

    {% gist swieeft/e5ae1c27e5c97a32eadd38c8cf604825 EnumBasic-2.swift %}

    열거형은 위와 같이 쉼표(,)로 구분하여 한 줄로 선언할 수도 있습니다.

### 열거형 변수 및 패턴 매칭을 통한 열거형 사용법

---

위와 같이 열거형이 선언되고, 열거형을 사용하기 위한 변수를 만들 수 있습니다.

- **열거형 변수 생성**

    ```swift
    var 주문메뉴: 메뉴판 = 메뉴판.김밥
    
    /** 타입을 미리 지정 해줬기 때문에 타입을 제외하고 설정 가능합니다 **/
    var 주문메뉴: 메뉴판 = .김밥
    
    /** 타입 추론을 통해 타입을 지정하지 않아도 자동으로 타입이 설정됩니다 **/
    var 주문메뉴 = 메뉴판.김밥
    ```

- **열거형 변수 값 변경**

    ```swift
    /** 같은 타입인 CompassPoint 내부 항목에서만 지정 가능합니다 **/
    주문메뉴 = .라면
    ```

- **열거형 변수 print**

    ```swift
    print(주문메뉴)
    /** 라면 **/
    ```

    열거형 변수를 print 문을 통해 출력하면 변수 안에 설정 된 값이 출력 됩니다. 위의 코드에서는 **라면**이 출력이 될 것 입니다. 

    print를 통해 보면 문자열 처럼 보일 수 있지만 **분식집.라면**이 하나의 고유 값이기 때문에  아래와 같이 문자열로 비교할 수 없습니다.

    ```swift
    if 주문메뉴 == "라면" { } /** 문법 오류! **/
    ```

- **패턴 매칭을 통한 열거형 사용법**

    ```swift
    /** 스위치 문을 활용한 열거형 사용 **/
    switch 주문메뉴 {
    case .라면:
        print("라면")
    default:
        print("메뉴없음")
    }
    
    /** 선언된 case를 모두 입력하면 default를 생략 가능합니다 **/
    switch 주문메뉴 {
    case .라면:
        print("라면")
    case .김밥:
        print("김밥")
    case .찌개:
        print("찌개")
    case .떡볶이:
        print("떡볶이")
    }
    /** if case를 이용해 사용 할 수 있습니다 **/
    if case .라면 = 주문메뉴 {
        print("라면")
    }
    
    /** 일반적인 if문 처럼 비교해 사용할 수 있습니다 **/
    if 주문메뉴 == .라면 {
        print("라면")
    }
    ```

### 내부(Sub) 열거형

---

열거형의 서브 타입을 이용하여 좀 더 세분화 된 케이스를 사용하고 싶다면 내부 열거형을 만들어서 사용하면 됩니다. 

- **내부 열거형 선언**

    ```swift
    enum 메뉴판 {
        enum 라면 {
            case 라면
            case 떡라면
            case 치즈라면
            case 만두라면
        }
    
        enum 김밥 {
            case 야채김밥
            case 참치김밥
            case 불고기김밥
        }
    
        enum 찌개 {
            case 된장찌개
            case 김치찌개
            case 순두부찌개
        }
        
        enum 떡볶이 {
            case 국물떡볶이
            case 치즈떡볶이
            case 짜장떡볶이
        }
    }
    ```

    분식집은 여러가지 종류의 메뉴가 있습니다. 그래서 분식집 메뉴판을 보면 전체 메뉴판 안에 소메뉴를 두어 각각의 타입을 분류 하므로 손님이 메뉴판을 더 쉽게 볼 수 있게 해줍니다.

- **내부 열거형 변수 생성**

    ```swift
    let 라면 = 메뉴판.라면.떡라면
    let 김밥 = 메뉴판.김밥.야채김밥
    let 찌개 = 메뉴판.찌개.순두부찌개
    let 떡볶이 = 메뉴판.떡볶이.국물떡볶이
    ```

    이렇게 각 메뉴별로 세분화 된 메뉴를 선택할 수 있는 계층적인 방법이 만들어졌습니다.

- **클래스, 구조체에 내부 열거형 선언**

    ```swift
    struct 메뉴판 {
        enum 라면 {
            case 라면
            case 떡라면
            case 치즈라면
            case 만두라면
        }
    
        enum 김밥 {
            case 야채김밥
            case 참치김밥
            case 불고기김밥
        }
    
        let 주문한_라면: 라면
        let 주문한_김밥: 김밥
    }
    
    let 메뉴주문 = 메뉴판(주문한_라면: .만두라면, 주문한_김밥: .불고기김밥)
    ```

    열거형 내부에 열거형을 선언할 수 있듯이 클래스, 구조체 내부에도 열거형을 사용할 수 있습니다.

### 원시 값(Raw Values)

---

스위프트 열거형의 경우 다른 언어와는 다르게 고유한 자신만의 타입으로 생성이 됩니다. 뿐만 아니라 원시 값이라는 것을 통해 정수, 실수, 문자 등의 실제 값을 가질 수 있습니다. 

- **원시 값 지정**

    ```swift
    /** 문자 타입의 원시 값 **/
    enum 메뉴판: String {
        case 라면 = "Ramen"
        case 김밥 = "Gimbab"
        case 찌개 = "Jjigae"
        case 떡볶이 = "Tteokbokki"
    }
    
    /** 정수 타입의 원시 값 **/
    enum 메뉴판: Int {
        case 라면 = 0
        case 김밥 = 1
        case 찌개 = 2
        case 떡볶이 = 3
    }
    
    /** 실수 타입의 원시 값 **/
    enum 메뉴판: Double {
        case 라면 = 1.111
        case 김밥 = 2.222
        case 찌개 = 3.333
        case 떡볶이 = 4.444
    }
    ```

    원시 값을 지정하는 방법은 간단합니다. 선언 된 열거형 이름 옆에 원시 값으로 사용할 타입을 명시 해준 후 각 항목 마다 사용할 원시 값을 지정 해주면 됩니다.

- **원시 값 사용**

    원시 값을 사용하려면 rawValue라는 프로퍼티를 사용하면 됩니다.

    ```swift
    /** 문자 타입 **/
    let 주문메뉴 = 메뉴판.라면
    print(주문메뉴.rawValue) /** 라면 **/
    
    /** 정수 타입 **/
    let 주문메뉴 = 메뉴판.라면
    print(주문메뉴.rawValue) /** 0 **/
    
    /** 실수 타입 **/
    let 주문메뉴 = 메뉴판.라면
    print(주문메뉴.rawValue) /** 1.111 **/
    ```

- **원시 값 자동 처리**

    원시 값을 일부 항목에만 적용해도 Int, String은 스위프트가 알아서 자동으로 원시 값을 생성 해줍니다. 단, 실수 타입의 경우 자동 처리를 사용할 수 없습니다.

    - String 타입 원시 값 자동 처리

        ```swift
        enum 메뉴판: String {
            case 라면 = "Ramen"
            case 김밥 = "Gimbab"
            case 찌개
            case 떡볶이
        }
        
        print("\(메뉴판.김밥.rawValue), \(메뉴판.떡볶이.rawValue)")
        /** Gimbab, 떡볶이 **/
        ```

        String의 경우 원시 값이 지정 된 항목은 지정 된 값을 출력 해주고, 지정 안 된 항목의 경우는 항목 이름 그대로 출력 해줍니다.

    - Int 타입 원시 값 자동 처리

        ```swift
        enum 메뉴판: Int {
            case 라면
            case 김밥
            case 찌개
            case 떡볶이 = 100
        }
        
        
        print("\(메뉴판.라면.rawValue), \(메뉴판.찌개.rawValue), \(메뉴판.떡볶이.rawValue)")
        /** 0, 2, 100 **/
        ```

        Int의 경우 원시 값이 지정 된 항목은 지정 된 값을 출력 해주고, 그렇지 않으면 0부터 1씩 값이 늘어납니다.

        만약 제일 처음 north 값을 100으로 지정 해주면 어떻게 될까요?

        ```swift
        enum 메뉴판: Int {
            case 라면 = 100
            case 김밥
            case 찌개
            case 떡볶이
        }
        
        print("\(메뉴판.라면.rawValue), \(메뉴판.찌개.rawValue), \(메뉴판.떡볶이.rawValue)")
        /** 100, 102, 103 **/
        ```

        처음 시작하는 north의 값을 100으로 주고 시작하니 100에 1씩 증가한 값이 나오게 됩니다.

        그렇다면 중간에 값을 지정 해줬을 때도 궁금해지는 되요.

        ```swift
        enum 메뉴판: Int {
            case 라면
            case 김밥 = 100
            case 찌개
            case 떡볶이
        }
        
        print("\(메뉴판.라면.rawValue), \(메뉴판.찌개.rawValue), \(메뉴판.떡볶이.rawValue)")
        /** 0, 101, 102 **/
        ```

        처음엔 0부터 1씩 증가하다가 지정된 값이 있다면 그 뒤엔 지정 된 값에 1씩 증가하면서 출력되는 것을 볼 수 있습니다. 

- **원시 값을 이용해 열거형 초기화**

    원시 값을 알고 있으면 원시 값을 이용해서 열거형을 초기화해 변수를 만들어 줄 수 있습니다. 단, 원시 값이 열거형에 정의 되어 있지 않다면 nil을 반환하게 되므로 생성되는 변수는 옵셔널 변수가 됩니다.

    ```swift
    enum 메뉴판: String {
        case 라면 = "Ramen"
        case 김밥 = "Gimbab"
        case 찌개 = "Jjigae"
        case 떡볶이 = "Tteokbokki"
    }
    
    let 주문메뉴 = 메뉴판(rawValue: "Gimbab")
    print(주문메뉴) /** 메뉴판.김밥 **/
    
    let 주문메뉴 = 메뉴판(rawValue: "돈까스")
    print(주문메뉴) /** 돈까스라는 원시 값은 없으므로 nil **/
    ```

### 연관 값(Associated Values)

---

연관 값은 스위프트 열거형의 특징 중 하나로 열거형의 항목들이 각각 자신의 연관 값을 가질 수 있습니다. 연관 값은 각 항목 옆에 튜플(Tuple) 형태로 만들 수 있습니다. 연관 값은 모든 항목에 들어갈 필요는 없습니다.

연관 값을 사용하게 되면 원시 값은 사용할 수 없습니다.

- **연관 값을 가지는 항목 만들기**

    ```swift
    enum 메뉴판 {
        case 라면(재료: String, 갯수: Int)
        case 김밥(재료: String, 갯수: Int)
    }
    ```

    지금까지는 메뉴판에 정해진 메뉴만 시킬 수 있었다면, 연관 값을 이용해 메뉴를 선택 후 원하는 재료를 고르고 몇개를 주문할 지 선택할 수 있게 만들었습니다.

    메뉴들의 연관 값은 재료: String와 갯수: Int로 되어 있습니다.

- **연관 값 사용**

    ```swift
    let 라면주문 = 메뉴판.라면(재료: "치즈", 갯수: 1)
    if case let 메뉴판.라면(재료, 갯수) = 라면주문 {
        print("주문하신 라면은 \(재료)라면이고, \(갯수)개를 주문하셨습니다.")
    }
    /** 주문하신 라면은 치즈라면이고, 1개를 주문하셨습니다. **/
    
    let 김밥주문 = 메뉴판.김밥(재료: "참치", 갯수: 2)
    if case let 메뉴판.김밥(재료, 갯수) = 김밥주문 {
        print("주문하신 김밥은 \(재료)김밥이고, \(갯수)개를 주문하셨습니다.")
    }
    /** 주문하신 김밥은 참치김밥이고, 2개를 주문하셨습니다. **/
    ```

    연관 값을 사용할 땐 패턴 매칭을 사용하시면 됩니다.

- **레이블이 없는 연관 값**

    ```swift
    enum 메뉴판 {
        case 라면(String, Int)
        case 김밥(String, Int)
    }
    ```

    연관 값에 레이블을 생략해서 작성할 수 있습니다. 하지만 이렇게 사용하면 어떤 값이 들어와야 되는지 명확하지 않을 수 있어 사용에 유의해야 합니다.

- **내부 열거형을 이용한 연관 값 사용**

    재료를 손님이 원하는 대로 넣어주기엔 케이스가 많기 때문에 분식집에서 사용할 수 있는 재료로 한정해서 메뉴를 고를 수 있도록 만들어야 합니다.

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
        
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
        }
        
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
        }
    }
    
    let 라면주문 = 메뉴판.라면(재료: .만두, 갯수: 1)
    if case let 메뉴판.라면(재료, 갯수) = 라면주문 {
        print("주문하신 라면은 \(재료)라면이고, \(갯수)개를 주문하셨습니다.")
    }
    /** 주문하신 라면은 만두라면이고, 1개를 주문하셨습니다. **/
    
    let 김밥주문 = 메뉴판.김밥(재료: .야채, 갯수: 2)
    if case let 메뉴판.김밥(재료, 갯수) = 김밥주문 {
        print("주문하신 김밥은 \(재료)김밥이고, \(갯수)개를 주문하셨습니다.")
    }
    /** 주문하신 김밥은 야채김밥이고, 2개를 주문하셨습니다. **/
    ```

    라면은 떡, 치즈, 만두로 김밥은 야채, 참치, 김치로만 재료를 선택할 수 있게 내부 열거형을 선언한 후 연관 값의 재료 타입을 내부 열거형으로 바꾸어 손님이 정해진 재료에서만 메뉴를 선택할 수 있도록 만들어 줍니다.

### 열거형 내부 프로퍼티(Property)

---

열거형에서도 프로퍼티를 사용할 수 있습니다. 하지만 저장 프로퍼티는 사용하지 못하고, 연산 프로퍼티만 사용 가능합니다.

- **프로퍼티 선언하기**

    ```swift
    enum 분식집 {
        case 라면(토핑: 라면토핑, 인분: Int)
        case 김밥(메인재료: 김밥재료, 인분: Int)
    
        enum 라면토핑 {
            case 없음
            case 떡
            case 치즈
            case 만두
        }
    
        enum 김밥재료 {
            case 야채
            case 참치
            case 불고기
        }
    
        var 메뉴: String {
            switch self {
            case let .라면(토핑, _):
                return "\(토핑)라면"
            case let .김밥(메인재료, _):
                return "\(메인재료)김밥"
            }
        }
    }
    ```

    메뉴라는 연산 프로퍼티를 만들어 주었습니다. 프로퍼티는 모든 항목에서 동일하게 동작하므로 switch문을 이용해 적절히 분기하여 사용해야 합니다.

- **프로퍼티 사용하기**

    ```swift
    let 라면주문 = 메뉴판.라면(재료: .만두, 갯수: 1)
    print(라면주문.메뉴이름) /** 만두라면 **/
    
    let 김밥주문 = 메뉴판.김밥(재료: .야채, 갯수: 2)
    print(김밥주문.메뉴이름) /** 야채김밥 **/
    ```

    메뉴이름 프로퍼티를 사용하여 현재 선택된 재료로 만든 메뉴이름을 받을 수 있습니다.

- **프로퍼티로 원시 값 만들기**

    연관 값을 사용하면 원시 값을 사용하지 못한다고 하였습니다. 하지만 프로퍼티를 이용하면 원시 값 처럼 사용할 수 있게 만들 수 있습니다.

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
        
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
        }
        
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
        }
        
        var rawValue: Int {
            switch self {
            case .라면:
                return 0
            case .김밥:
                return 1
            }
        }
    }
    
    let 라면주문 = 메뉴판.라면(재료: .만두, 갯수: 1)
    print(라면주문.rawValue) /** 0 **/
    
    let 김밥주문 = 메뉴판.김밥(재료: .야채, 갯수: 2)
    print(김밥주문.rawValue) /** 1 **/
    ```

    만약 연관 값과 원시 값을 함께 사용하고 싶으시면 위와 같이 프로퍼티를 이용해서 사용하시면 됩니다.

- **정적 프로퍼티**

    열거형에서도 프로퍼티를 정적으로 만들 수 있습니다. 구조체나 클래스에서 정적 프로퍼티를 만들듯이 프로퍼티 앞에 **static** 키워드를 넣어주면 됩니다.

    ```swift
    enum 메뉴판 {
        case 라면
        case 김밥
        case 찌개
        case 떡볶이
        
        static let allMenu: [메뉴판] = [.라면, .김밥, .찌개, .떡볶이]
    }
    
    메뉴판.allMenu.forEach { 메뉴 in
        print(메뉴)
    }
    /**
    라면
    김밥
    찌개
    떡볶이
    **/
    ```

    정적 프로퍼티를 이용해서 메뉴판에 있는 모든 메뉴를 가져오도록 allMenu라는 정적 프로퍼티를 만들어 사용하였습니다. 이렇게 정적 프로퍼티는 현재 열거형의 모든 항목을 가져오고 싶을 때 많이 사용 되어집니다. 

### 열거형 내부 메서드(Method)

---

스위프트 열거형에서는 내부에 메서드도 구현을 할 수 있습니다. 메서드를 구현 해주어 각 항목에 따른 기능을 구현 해줄 수 있습니다.

- **메서드 선언**

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
    
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
        }
    
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
        }
        
        func 갯수추가하기(_ 추가갯수: Int) {
            switch self {
            case let .라면(재료, 갯수):
                print("\(재료)라면을 추가하여 총 \(갯수 + 추가갯수)개를 주문하였습니다.")
            case let .김밥(재료, 갯수):
                print("\(재료)김밥을 추가하여 총 \(갯수 + 추가갯수)개를 주문하였습니다.")
            }
        }
    }
    ```

    주문한 메뉴의 갯수를 추가 할 수 있게 갯수추가하기라는 메서드를 선언하였습니다. 이 메서드 안에서는 먼저 주문한 메뉴의 갯수과 추가 주문한 갯수를 더한 값을 print합니다.

    메서드도 프로퍼티와 마찬가지로 모든 항목이 동일한 메서드를 사용하기 때문에 switch문을 이용해 적절히 분기하여 사용해야 합니다.

- **메서드 사용**

    ```swift
    let 라면주문 = 메뉴판.라면(재료: .만두, 갯수: 1)
    라면주문.갯수추가하기(2)
    /** 만두라면을 추가하여 총 3개를 주문하였습니다. **/
    
    let 김밥주문 = 메뉴판.김밥(재료: .야채, 갯수: 2)
    김밥주문.갯수추가하기(3)
    /** 야채김밥을 추가하여 총 5개를 주문하였습니다. **/
    ```

    메서드를 호출해보면 갯수가 제대로 계산되어 print 되는 것을 확인 할 수 있습니다.

- **정적 메서드**

    메서드도 클래스, 구조체에서 처럼 정적 메서드를 만들어서 사용할 수 있습니다. 정적 메서드는 메서드 선언할 때 앞에 **static** 키워드를 추가하면 됩니다.

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
    
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
            
            static let all: [라면재료] = [.떡, .치즈, .만두]
        }
    
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
            
            static let all: [김밥재료] = [.야채, .참치, .김치]
        }
        
        static func 메뉴판주세요() {
            print("===라면류===")
            메뉴판.라면재료.all.forEach { 재료 in
                print("\(재료)라면")
            }
            print("===김밥류===")
            메뉴판.김밥재료.all.forEach { 재료 in
                print("\(재료)김밥")
            }
        }
    }
    
    메뉴판.메뉴판주세요()
    /**
    ===라면류===
    떡라면
    치즈라면
    만두라면
    ===김밥류===
    야채김밥
    참치김밥
    김치김밥
    **/
    ```

    정적 메서드를 만들어 메뉴판의 모든 메뉴를 출력하는 함수를 만들었습니다. 정적 메서드에 대한 기본적인 느낌을 알아보습니다.

    하지만 정적 메서드를 가장 많이 활용하는 것은 위의 코드처럼 단순 print용으로 사용되는 것이 아니라 API로 받아온 값을 열거형으로 바꿀 때 많이 사용 됩니다.

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
    
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
            
            static let all: [라면재료] = [.떡, .치즈, .만두]
        }
    
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
            
            static let all: [김밥재료] = [.야채, .참치, .김치]
        }
        
        static func 이메뉴있나요(메뉴: String, 재료: String, 갯수: Int) -> 메뉴판? {
            switch 메뉴 {
            case "라면":
                switch 재료 {
                case "떡":
                    return .라면(재료: .떡, 갯수: 갯수)
                case "치즈":
                    return .라면(재료: .치즈, 갯수: 갯수)
                case "만두":
                    return .라면(재료: .만두, 갯수: 갯수)
                default:
                    return nil
                }
            case "김밥":
                switch 재료 {
                case "야채":
                    return .김밥(재료: .야채, 갯수: 갯수)
                case "참치":
                    return .김밥(재료: .참치, 갯수: 갯수)
                case "김치":
                    return .김밥(재료: .김치, 갯수: 갯수)
                default:
                    return nil
                }
            default:
                return nil
            }
        }
    
            var 메뉴이름: String {
            switch self {
            case let .라면(재료, _):
                return "\(재료)라면"
            case let .김밥(재료, _):
                return "\(재료)김밥"
            }
        }
    }
    
    if let 주문메뉴 = 메뉴판.이메뉴있나요(메뉴: "라면", 재료: "떡", 갯수: 1) {
        print(주문메뉴.메뉴이름)
    } else {
        print("그런 메뉴는 없어요")
    }
    /** 떡라면 **/
    
    if let 주문메뉴 = 메뉴판.이메뉴있나요(메뉴: "김밥", 재료: "불고기", 갯수: 1) {
        print(주문메뉴.메뉴이름)
    } else {
        print("그런 메뉴는 없어요")
    }
    /** 불고기 김밥은 메뉴에 없기 떄문에 nil **/
    ```

    위의 코드처럼 API에서 메뉴, 재료, 갯수를 내려주면 유효한 메뉴인지 판단하는 함수를 만들어서 사용할 수 있습니다. 

    API 내려주는 메뉴는 String이기 때문에 정적 메소드를 만들어 값을 넣고 유효한 값이면 열거형 타입을 반환하고 아니면 nil을 반환하는 함수를 만들어서 체크하는 기능을 만들 수 있습니다.

- **변경 메서드**

    열거형도 구조체와 마찬가지로 Call by Value이기 때문에 내부 메서드에서 현재 값을 변경하려면 **mutating** 키워드를 사용해야 self를 변경할 수 있습니다.

    ```swift
    enum 메뉴판 {
        case 라면(재료: 라면재료, 갯수: Int)
        case 김밥(재료: 김밥재료, 갯수: Int)
    
        enum 라면재료 {
            case 떡
            case 치즈
            case 만두
            
            static let all: [라면재료] = [.떡, .치즈, .만두]
        }
    
        enum 김밥재료 {
            case 야채
            case 참치
            case 김치
            
            static let all: [김밥재료] = [.야채, .참치, .김치]
        }
        
            mutating func 라면잘못주문했어요(재료: 라면재료, 갯수: Int) {
            self = .라면(재료: 재료, 갯수: 갯수)
        }
        
        mutating func 김밥잘못주문했어요(재료: 김밥재료, 갯수: Int) {
            self = .김밥(재료: 재료, 갯수: 갯수)
        }
    
            var 메뉴이름: String {
            switch self {
            case let .라면(재료, _):
                return "\(재료)라면"
            case let .김밥(재료, _):
                return "\(재료)김밥"
            }
        }
    }
    
    var 라면주문 = 메뉴판.라면(재료: .만두, 갯수: 1)
    print(라면주문.메뉴이름) /** 만두라면 **/
    
    라면주문.라면잘못주문했어요(재료: .치즈, 갯수: 1)
    print(라면주문.메뉴이름) /** 치즈라면 **/
    
    var 김밥주문 = 메뉴판.김밥(재료: .야채, 갯수: 2)
    print(김밥주문.메뉴이름) /** 야채김밥 **/
    
    김밥주문.김밥잘못주문했어요(재료: .김치, 갯수: 2)
    print(김밥주문.메뉴이름) /** 김치김밥 **/
    ```

    재료를 바꾸어 self에 넣어주고 다시 메뉴이름을 출력하면 정상적으로 바뀐 재료로 표시되는 것을 확인할 수 있습니다.

### 마무리

---

지금까지 열거형 기본편을 알아보았습니다. 기존에 다른 언어에서 알던 열거형과는 다른 하나의 근사한 데이터 타입으로 탄생한 스위프트 열거형입니다.

저도 열거형의 기능을 알고 난 뒤로 많은 부분을 열거형으로 바꿔서 코드를 깔끔하게 짰던 것이 생각이 납니다. 예제는 단편적인 예 밖에 들지 못 했지만 프로젝트를 하다보면 공통적으로 묶여야 되는 부분들도 많고 한데 적절히 열거형을 활용해보면 좋을 것 같습니다.

저 같은 경우에는 API 파라메터에 대한 부분을 열거형으로 만들어 놓고 쓰는데 여러분도 프로젝트에서 어떤 부분을 열거형으로 쓰면 좋을지 생각 해보셨으면 좋겠습니다.

생각보다 긴 글이 되었는데 끝까지 읽어주셔서 감사합니다. 달콤한 개발 되세요!

### 참고자료

---

- [Enumerations - The Swift Programming Language (Swift 5.2)](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html)

- [열거형의 고급 활용과 모범 사례](https://outofbedlam.github.io/swift/2016/04/05/EnumBestPractice/)

- [스위프트 프로그래밍 2판](http://www.hanbit.co.kr/store/books/look.php?p_code=B2206901403)
    - 저자 : 야곰
    - 출판사 : 한빛 미디어
    - 98쪽 4.5 열거형을 참고하였습니다.